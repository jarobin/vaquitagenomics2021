### Finding_SynNonSyn_Sites_nostopcodons_allfold_20210302.py
# Clare Marsden 2015
#
# March 2021 - Updated by Jacqueline to:
# - Ignore codons with any base not in [A,C,G,T]
# - Specify the reference fasta at the command line
# - Output 1-based positions instead of 0-based positions
#
##  The script takes a bed file of transcript exons, extracts the sequence from the genome and builds a concatenated sequence
##  i.e.   -----   ------   ------  ------   =>   ------------------------------------
##  It assumes this is fully CDS (without intronic sequence) starting with ATG and ending with a stop codon.
##  The script then takes the concatenated sequence, and moves along it testing if the site is a four-fold, zero-fold site or other  
##  It then outputs a file with the list of the chromosome name and the position, and whether the position was 0-, 4-, or other fold site.
##  The position it outputs is a zero based coordinate and is generated by referring back to the bed file
##  ASSUMPTIONS *****
##  BED file has a set of transcripts, which if put together make up a full CDS (without intronic sequence) starting with ATG and ending with a stop codon.
##
## Usage:
## SCRIPT=Finding_SynNonSyn_Sites_nostopcodons_allfold_20210302.py
## python ${SCRIPT} {reference.fasta} {coords.bed} {outfile.txt}

import argparse
import HTSeq
import Bio
import itertools
import sys
from itertools import groupby
from Bio.Seq import Seq
from Bio.Seq import MutableSeq
from Bio.Alphabet import IUPAC
from Bio.Data import CodonTable
from Bio import SeqIO

##  Variables
winsize=3
step=3

## paths
#REFERENCE_GENOME = '/wynton/group/wall/jacqueline/vaquita/analysis/zero_fourfold/mPhoSin1.pri.cur.20190723_rename.fasta'

## Functions
def htseq_index_genome(GENOME_PATH):
    '''
    uses HTSeq to index genome sequence in GENOME_PATH (fasta)
    returns dict that can be queried for sequence with coordinates
    requires import HTSeq
    The genome fasta file is something like >chr01, next line the sequence for chromosome 1, the same for all the other chromsomes
    Essentially the command reads the whole fasta file into memory to access it as a dictionary, 
    where key = chr01 (or chr02) and value is the sequence.
    So .... s.name is chr01 or chr02, chr03 .... and s is the sequence.
    '''
    return dict((s.name, s) for s in HTSeq.FastaReader(GENOME_PATH))

def htseq_query_genome(chromo, start, end, indexed_genome):
    '''
    queries indexed genome for corresponing sequence to the coordinates provided
    returns string with sequence
    requires import HTSeq
    So indexed genome is the dictionary of sequences in htseq_index_genome
    It goes to the chromosome you request and pulls out sequence between start and end you specify
    '''
    return indexed_genome[chromo].seq[int(start):int(end)]

def parse_region_bed(filename):
    '''
    parses a .bed file containing region coordinates and
    returns a dict in form region_name: [chromo, [(start, end)...], strand]
    Essentially the bed file has lots of coordinates for different exons of the same CDS e.g. ENSCAFT00001  (i.e. name in the bed)
    You are making a dictionary where the key is the gene - then values are a list I think
    The list is the 1) chromosome, 2) a tupule of coordinates, 3) then the strand
    You only add when the CDS is the same - so essentially all the transcripts of the CDS
    '''
    region_dict = {}
    for line in open(filename, 'r'):
        chromo, start, end, name, strand = line.strip().split()[:5]
        if name not in region_dict:
            region_dict[name] = [chromo, [(start, end)], strand]
# The 1 here means item one in the list i.e. the second element 
        else:
            region_dict[name][1].append((start, end))
    return region_dict

def build_region_reference_sequence(coordinates, indexed_genome):
    '''
    takes coordinates in list form [chromo, [(start, end)...], strand] (as build by parse_region_bed function) 
    e.g. ['chr02', [('1294185', '1294326'), ('1317868', '1318829'), ('1318869', '1319888'), ('1320524', '1321421')], '+']
    it loops through each pair of coords e.g. 1294185-1294326 then 1317868-1318829
    and returns string of sequence from reference genome (indexed_genome) using htseq_query_genome function
    requires from Bio.Seq import Seq
    '''
    chromo, coords, strand = coordinates
    seq = ''
    for (start, end) in coords:
        seq += htseq_query_genome(chromo, start, end, indexed_genome)
    if strand == '-':
        seq = str(Seq(seq).reverse_complement())
    return seq

def find_genomic_position(relative_position, coordinates):
    '''
    returns the absolute genomic position given its relative position in a region
    and the region coordinates in list form [chromo, [(start, end)...], strand] (as build by parse_region_bed function)
    ! all coordinates are 0-based, open-ended (.bed format convention)!
    '''
    chromo, coords, strand = coordinates
    region_length = sum([(int(end) - int(start)) for start, end in coords])

    if strand == '-':
        relative_position = region_length - relative_position - 1

    current_relative_position = -1
    for start, end in coords:
        portion_length = int(end) - int(start)
        current_relative_position += portion_length

        if relative_position <= current_relative_position:
            absolute_position = int(start) + portion_length - 1 - (current_relative_position - relative_position)
            break

    return absolute_position


def CodonConvert(codon,triplet_pos):
    '''
    Tests of the site is Zero fold, Four Fold or Other. If there is an N in the triplet it passes it.
    Four fold is if when you subsitute in ACGT, you get the same amino acid each time - i.e. synonymous site
    Zero fold is where you changing the nuclotide always changes the amino acid (non-degenerate)
    Here Zero fold change to any other nucleotide it changes the output. This includes PQRL, PQR*, PQ**, P***
    '''
    posbases=["A", "C", "G", "T"]
    aa=[]
    for i in posbases:
        if any(x not in ['A','C','G','T'] for x in codon):
            pass
        else:
            codon_mutseq = codon.tomutable()
            codon_mutseq[triplet_pos] = i
            codon_seq = codon_mutseq.toseq()
            trans_codon = codon_seq.translate()
            aa.append(str(trans_codon))
    degen = len(set(aa))
    sortedaa=sorted(aa) # sorted list so i can do the next bit
    # this counts the number of each aa - must be sorted list to start
    aacounts=[len(list(group)) for key, group in groupby(sortedaa)]
    
## A position of a codon is said to be a n-fold degenerate site if only n of four possible nucleotides (A, C, G, T) at this position specify the same amino acid
    if aa.count('*') > 0:
        fold_site = 'StopCodon'
    elif degen == 0:
        fold_site = 'N_inCodon'
    ## this has to come here after the above two options
    elif len(aa) != 4:
#         print 'unexpected option for len(aa) not 4. aa:', aa
#         fold_site='ERROR_not4'
        sys.exit('#### error exiting - expecting 4 amino acids, didnt get that')
    elif degen == 1:
    	if aacounts == [4]:
            fold_site = 'Four_Fold'  # i.e. synonymous
        else:
            sys.exit('## error exiting four fold')
    elif degen == 4:
        if aacounts == [1,1,1,1]:  # this is something like either PQRL
            fold_site = 'Zero_Fold'
        else:
            sys.exit('## error exiting zero fold')
    elif 2 in aacounts:
        fold_site = 'Two_Fold'
    elif 3 in aacounts:
        fold_site = 'Three_Fold'
    else:
         print 'Elsed out, aa: ', aa, 'degen', degen, 'aacounts', aacounts, 'sortedaacount', sorted(aacounts)
         fold_site='ERROR'
#        sys.exit('#$###$# error exiting unexpected option')

#    else:
#        fold_site = 'OtherFold'
    return fold_site

## parsing command line arguments
argparser = argparse.ArgumentParser()
argparser.add_argument('reference_fasta', help='reference genome sequence (.fa or .fasta)')
argparser.add_argument('coords', help='genomic coordinates of regions in alignment (.bed)')
argparser.add_argument('filename', help='output file, comment line, then header, then data in tab delimited format')
args = argparser.parse_args()

Outfilename = args.filename
Outfile = open(Outfilename, 'w')
REFERENCE_GENOME = args.reference_fasta
coords = args.coords

## Sequence of events    
print '### Indexing reference genome in %s...' % REFERENCE_GENOME
ref_genome = htseq_index_genome(REFERENCE_GENOME)
print '### ...done!'    

print '### Loading region coordinates...'
region_dict = parse_region_bed(coords)
print '### ...done!'

print '### Starting to parse transcripts to determine syn and non-syn sites ####'

Outfile.write('### This file is the output of a script that parsed through transcript sequences. The output is whether the site was zero fold i.e. non-syn, four fold i.e. syn degenerate site or other\n')
Outfile.write('#chromosome'+'\t'+'position' + '\t' + 'site_type' + '\n')

## its for each region e.g. gene. So coords = e.g. ['chr02', [('1251', '2340'), ('56789', '60789')], '+']
## extracted sequence is the sequence for the entire region - i.e. all those coordinates, so the CDS from start to finish   
## ref_seq = extracted_seq transformmed into something readable for translation using Bio.Seq
## the num chunks thing is because we don't want to have codon's where < 3 that can't be translated

for region in region_dict:
    coords = region_dict[region]
    extracted_seq = build_region_reference_sequence(coords, ref_genome)

    ref_seq=Seq(extracted_seq, IUPAC.unambiguous_dna)
    region_len = len(ref_seq)
    num_of_chunks = region_len/winsize 

    codon_position = -1
    
    for i in range(0, num_of_chunks*step, step):
         codon_position += 1
         ref_codon = ref_seq[i:i+3]
#        # compare each codon position
#        # j is the triplet position 0,1,2, ref_base is the base, ref_codon is the codon
         for j, ref_base in enumerate(ref_codon):
             rel_nucleotide_position = j + (codon_position*3)
             abs_nucleotide_position = find_genomic_position(rel_nucleotide_position, coords)
             fold_site = CodonConvert(ref_codon, j)
             Outfile.write(str(coords[0]) + '\t' + str(abs_nucleotide_position+1) + '\t' + str(fold_site) + '\n')
#             print 'chromosome\ttripletposition_012\tbase\tcodon\tfoldsite\trelative_nucleotide_position\tabsolute_nucleotide_position'           
#             print coords[0], j, ref_base, ref_codon, fold_site, rel_nucleotide_position, abs_nucleotide_position

